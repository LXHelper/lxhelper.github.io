<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="robots" content="noindex, nofollow">
  <title>Restaurant Finder</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body { 
      font-family: system-ui, sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #f8f9fa;
    }

    /* Desktop Layout - Original Design */
    .container { 
      display: flex; 
      height: 100vh; 
    }
    
    #map { 
      flex: 1; 
      min-height: 500px; 
    }

    #controls-panel {
      width: 320px;
      padding: 16px;
      background: #f8f9fa;
      overflow-y: auto;
      border-right: 1px solid #ddd;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
      box-sizing: border-box;
    }

    button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin: 4px 4px 4px 0;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    button:hover {
      opacity: 0.9;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    .toggle-row label {
      margin: 0;
      font-size: 12px;
    }

    input[type="checkbox"] {
      width: auto;
    }

    #results {
      max-height: 320px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #results li {
      margin: 0;
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      font-size: 12px;
      line-height: 1.3;
    }

    #results li:hover {
      background: #f0f0f0;
    }

    #results li.selected {
      background: #e8f5e8;
      border-left: 4px solid #28a745;
    }

    #results li:last-child {
      border-bottom: none;
    }

    .new-result {
      background: #e8f5e8 !important;
      animation: highlight 2s ease-out;
    }

    @keyframes highlight {
      0% { background: #90ee90 !important; }
      100% { background: #e8f5e8 !important; }
    }

    #status {
      padding: 8px;
      margin-top: 8px;
      background: #e9ecef;
      border-radius: 4px;
      font-size: 12px;
      min-height: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      margin: 8px 0;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #007bff;
      transition: width 0.3s ease;
      width: 0%;
    }

    .coords-row {
      display: flex;
      gap: 8px;
    }

    .coords-row .form-group {
      flex: 1;
    }

    .stats {
      background: white;
      padding: 8px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 12px;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
    }

    /* Mobile Optimizations */
    @media (max-width: 767px) {
      .container {
        flex-direction: column;
        height: 100vh;
      }

      #controls-panel {
        width: 100%;
        height: auto;
        max-height: 50vh;
        border-right: none;
        border-bottom: 1px solid #ddd;
        position: relative;
        z-index: 1000;
      }

      .mobile-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #ddd;
      }

      .mobile-header h3 {
        margin: 0;
        font-size: 16px;
      }

      .controls-toggle {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        cursor: pointer;
      }

      .controls-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .controls-content.expanded {
        max-height: 40vh;
        overflow-y: auto;
      }

      .form-group input,
      .form-group select {
        padding: 12px 8px;
        font-size: 16px;
        min-height: 44px;
      }

      button {
        padding: 12px 16px;
        font-size: 14px;
        min-height: 44px;
      }

      .toggle-row {
        min-height: 44px;
      }

      #map {
        flex: 1;
        min-height: 300px;
      }

      #results {
        max-height: 200px;
      }

      #results li {
        padding: 12px;
        font-size: 14px;
        min-height: 44px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        text-align: center;
      }

      .stat-item {
        flex-direction: column;
        background: #007bff;
        color: white;
        padding: 8px;
        border-radius: 8px;
      }

      .stat-item span:first-child {
        font-size: 10px;
        opacity: 0.8;
      }

      .stat-item span:last-child {
        font-size: 16px;
        font-weight: bold;
      }
    }

    /* Loading animation */
    .btn.loading {
      position: relative;
      color: transparent;
    }

    .btn.loading::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
    }

    @keyframes spin {
      to {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="controls-panel">
      <!-- Mobile header -->
      <div class="mobile-header">
        <h3>Restaurant Finder</h3>
        <button class="controls-toggle" id="controlsToggle">Settings</button>
      </div>

      <!-- Desktop title (hidden on mobile) -->
      <h3 style="margin-top: 0; display: none;">Restaurant Finder</h3>

      <div class="controls-content" id="controlsContent">
        <div class="form-group">
          <label>Search Center</label>
          <div class="coords-row">
            <div class="form-group">
              <input type="number" id="centerLat" step="0.001" placeholder="Latitude" value="44.437">
            </div>
            <div class="form-group">
              <input type="number" id="centerLng" step="0.001" placeholder="Longitude" value="26.097">
            </div>
          </div>
          <button type="button" class="btn-secondary" id="getCurrentLocation">Use My Location</button>
        </div>

        <div class="form-group">
          <label>Search Radius (km)</label>
          <input type="number" id="outerRadius" min="1" max="50" step="1" value="5">
        </div>

        <div class="form-group">
          <label>Cell Size (meters)</label>
          <input type="number" id="cellRadius" min="500" max="5000" step="100" value="1000">
        </div>

        <div class="form-group">
          <label>Minimum Rating</label>
          <select id="minRating">
            <option value="4.0">4.0+</option>
            <option value="4.2">4.2+</option>
            <option value="4.5">4.5+</option>
            <option value="4.7">4.7+</option>
            <option value="4.8" selected>4.8+</option>
            <option value="4.9">4.9+</option>
          </select>
        </div>

        <div class="form-group">
          <label>Minimum Reviews</label>
          <select id="minReviews">
            <option value="100">100+</option>
            <option value="500">500+</option>
            <option value="1000" selected>1000+</option>
            <option value="2000">2000+</option>
            <option value="5000">5000+</option>
          </select>
        </div>

        <div class="toggle-row">
          <input type="checkbox" id="showCells" checked>
          <label for="showCells">Show scan cells</label>
        </div>

        <div class="toggle-row">
          <input type="checkbox" id="showProgress" checked>
          <label for="showProgress">Live results</label>
        </div>

        <div style="margin: 16px 0;">
          <button type="button" class="btn-primary" id="startSearch">Start Search</button>
          <button type="button" class="btn-danger" id="cancelSearch" disabled>Cancel</button>
          <button type="button" class="btn-secondary" id="clearResults">Clear</button>
        </div>

        <div class="progress-bar" id="progressBar">
          <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="status">Ready to search...</div>

        <div class="stats" id="statsPanel">
          <div class="stat-item">
            <span>Total Found:</span>
            <span id="totalCount">0</span>
          </div>
          <div class="stat-item">
            <span>Filtered:</span>
            <span id="filteredCount">0</span>
          </div>
          <div class="stat-item">
            <span>Cells Scanned:</span>
            <span id="cellsScanned">0/0</span>
          </div>
        </div>

        <div style="margin-top: 16px;">
          <strong>Results:</strong>
          <ul id="results"></ul>
        </div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // Configuration
    const CONFIG = {
      API_KEY: 'AIzaSyD0yHf3IW0QT2Rsu69esI_PzP0KXZLhksg'
    };

    let map, info, svc;
    let searchCancelled = false;
    let currentMarkers = [];
    let cellOverlays = [];
    let currentCellOverlay = null;
    let searchResults = new Map();
    let currentCellIndex = -1;
    let selectedMarker = null;
    let lastClickedPlace = null;
    let lastClickTime = 0;
    let controlsExpanded = false;

    // Utility functions
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const toRad = (x) => x * Math.PI / 180;

    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const s1 = toRad(a.lat);
      const s2 = toRad(b.lat);
      const A = Math.sin(dLat / 2) ** 2 + Math.cos(s1) * Math.cos(s2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(A));
    }

    // Mobile controls toggle
    function toggleControls() {
      const content = document.getElementById('controlsContent');
      const toggle = document.getElementById('controlsToggle');
      
      controlsExpanded = !controlsExpanded;
      
      if (controlsExpanded) {
        content.classList.add('expanded');
        toggle.textContent = 'Close';
      } else {
        content.classList.remove('expanded');
        toggle.textContent = 'Settings';
      }
    }

    // Marker and selection functions
    function createMarkerIcon(isSelected = false) {
      return {
        url: `https://maps.google.com/mapfiles/ms/icons/${isSelected ? 'green' : 'red'}-dot.png`,
        scaledSize: new google.maps.Size(32, 32),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(16, 32)
      };
    }

    function selectMarker(marker, place) {
      if (selectedMarker && selectedMarker !== marker) {
        selectedMarker.setIcon(createMarkerIcon(false));
      }

      selectedMarker = marker;
      marker.setIcon(createMarkerIcon(true));

      info.setContent(`<b>${place.name}</b><br>⭐ ${place.rating} (${place.user_ratings_total} reviews)<br><small>Click again to open in Google Maps</small>`);
      info.open(map, marker);
    }

    function generateGoogleMapsUrl(place) {
      if (place.place_id) {
        return `https://www.google.com/maps/place/?q=place_id:${place.place_id}`;
      }

      const lat = place.geometry.location.lat();
      const lng = place.geometry.location.lng();
      const name = encodeURIComponent(place.name);
      return `https://www.google.com/maps/search/${name}/@${lat},${lng},17z`;
    }

    function handlePlaceClick(place) {
      const currentTime = Date.now();
      const isDoubleClick = (lastClickedPlace === place.place_id && currentTime - lastClickTime < 500);

      if (isDoubleClick) {
        const url = generateGoogleMapsUrl(place);
        window.open(url, '_blank');
        lastClickedPlace = null;
      } else {
        const marker = currentMarkers.find(m => m.getTitle() === place.name);
        if (marker) {
          selectMarker(marker, place);
        }

        const listItems = document.querySelectorAll('#results li');
        listItems.forEach(li => li.classList.remove('selected'));

        const targetItem = [...listItems].find(li =>
          li.innerHTML.includes(`<strong>${place.name}</strong>`)
        );
        if (targetItem) {
          targetItem.classList.add('selected');
          targetItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        lastClickedPlace = place.place_id;
      }

      lastClickTime = currentTime;
    }

    // Visual cell functions
    function createCellOverlay(center, radius, isActive = false) {
      const circle = new google.maps.Circle({
        center: center,
        radius: radius,
        strokeColor: isActive ? '#ff4444' : '#4444ff',
        strokeOpacity: isActive ? 0.8 : 0.4,
        strokeWeight: isActive ? 3 : 1,
        fillColor: isActive ? '#ff4444' : '#4444ff',
        fillOpacity: isActive ? 0.15 : 0.05,
        map: document.getElementById('showCells').checked ? map : null
      });
      return circle;
    }

    function updateCurrentCell(center, radius) {
      if (currentCellOverlay) {
        currentCellOverlay.setMap(null);
      }
      if (document.getElementById('showCells').checked) {
        currentCellOverlay = createCellOverlay(center, radius, true);
      }
    }

    function clearVisualElements() {
      for (const overlay of cellOverlays) {
        overlay.setMap(null);
      }
      cellOverlays = [];

      if (currentCellOverlay) {
        currentCellOverlay.setMap(null);
        currentCellOverlay = null;
      }

      for (const marker of currentMarkers) {
        marker.setMap(null);
      }
      currentMarkers = [];

      selectedMarker = null;
      lastClickedPlace = null;
      lastClickTime = 0;

      searchResults.clear();
      currentCellIndex = -1;
      updateResultsList();
      updateStats();
    }

    // Search functions
    function nearbyAll(center, radius, cellIndex) {
      return new Promise((resolve, reject) => {
        if (searchCancelled) return resolve([]);

        let acc = [];
        const req = {
          location: center,
          radius,
          keyword: "restaurant"
        };

        const cb = (res, status, pag) => {
          if (searchCancelled) return resolve(acc);

          if (status === google.maps.places.PlacesServiceStatus.OK) {
            acc = acc.concat(res || []);

            if (document.getElementById('showProgress').checked && cellIndex === currentCellIndex) {
              processPartialResults(res || [], center, radius);
            }

            if (pag && pag.hasNextPage && !searchCancelled) {
              return setTimeout(() => pag.nextPage(), 2000);
            }
            resolve(acc);
          } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
            resolve(acc);
          } else {
            reject(status);
          }
        };

        svc.nearbySearch(req, cb);
      });
    }

    function textAll(center, radius, cellIndex) {
      return new Promise((resolve, reject) => {
        if (searchCancelled) return resolve([]);

        let acc = [];
        const req = {
          query: "restaurant",
          location: center,
          radius
        };

        const cb = (res, status, pag) => {
          if (searchCancelled) return resolve(acc);

          if (status === google.maps.places.PlacesServiceStatus.OK) {
            acc = acc.concat(res || []);

            if (document.getElementById('showProgress').checked && cellIndex === currentCellIndex) {
              processPartialResults(res || [], center, radius);
            }

            if (pag && pag.hasNextPage && !searchCancelled) {
              return setTimeout(() => pag.nextPage(), 2000);
            }
            resolve(acc);
          } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
            resolve(acc);
          } else {
            reject(status);
          }
        };

        svc.textSearch(req, cb);
      });
    }

    function processPartialResults(newPlaces, cellCenter, cellRadius) {
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      let newValidResults = [];

      for (const place of newPlaces) {
        if (!searchResults.has(place.place_id)) {
          const placeLocation = {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng()
          };

          const distanceToCell = haversine(cellCenter, placeLocation);

          if (distanceToCell <= cellRadius * 1.5) {
            searchResults.set(place.place_id, place);

            if ((place.types || []).includes("restaurant") &&
                (place.rating || 0) >= minRating &&
                (place.user_ratings_total || 0) >= minReviews) {
              newValidResults.push(place);
            }
          }
        }
      }

      if (newValidResults.length > 0) {
        addResultsToMap(newValidResults, true);
        updateResultsList();
        updateStats();
      }
    }

    function addResultsToMap(places, isNew = false) {
      for (const place of places) {
        const marker = new google.maps.Marker({
          position: place.geometry.location,
          map,
          title: place.name,
          icon: createMarkerIcon(false),
          animation: isNew ? google.maps.Animation.DROP : null
        });

        marker.placeData = place;

        marker.addListener("click", () => {
          handlePlaceClick(place);
        });

        currentMarkers.push(marker);
      }
    }

    function updateResultsList() {
      const ul = document.getElementById("results");
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      const filteredPlaces = [...searchResults.values()]
        .filter(p => (p.types || []).includes("restaurant"))
        .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews)
        .sort((a, b) => (b.rating - a.rating) || (b.user_ratings_total - a.user_ratings_total));

      ul.innerHTML = "";

      if (filteredPlaces.length === 0) {
        const li = document.createElement("li");
        li.textContent = searchResults.size > 0 ? "No restaurants match your criteria yet..." : "No results yet...";
        li.style.fontStyle = "italic";
        li.style.cursor = "default";
        ul.appendChild(li);
        return;
      }

      for (const place of filteredPlaces) {
        const li = document.createElement("li");
        li.innerHTML = `<strong>${place.name}</strong><br>⭐ ${place.rating} (${place.user_ratings_total} reviews)<br><small>Click again to open in Google Maps</small>`;

        li.onclick = () => handlePlaceClick(place);
        ul.appendChild(li);
      }

      ul.scrollTop = ul.scrollHeight;
    }

    function updateStats() {
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      const filteredCount = [...searchResults.values()]
        .filter(p => (p.types || []).includes("restaurant"))
        .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews)
        .length;

      document.getElementById('totalCount').textContent = searchResults.size;
      document.getElementById('filteredCount').textContent = filteredCount;
    }

    function buildGridCenters(center, outerKm, cellM) {
      const kmPerDegLat = 111.32;
      const stepKm = (cellM * 1.2) / 1000;
      const latStep = stepKm / kmPerDegLat;
      const lngStep = latStep / Math.cos(center.lat * Math.PI / 180);
      const steps = Math.ceil(outerKm / stepKm);
      const pts = [];

      for (let iy = -steps; iy <= steps; iy++) {
        for (let ix = -steps; ix <= steps; ix++) {
          const c = {
            lat: center.lat + iy * latStep,
            lng: center.lng + ix * lngStep
          };
          if (haversine(center, c) <= outerKm * 1000) {
            pts.push(c);
          }
        }
      }
      return pts;
    }

    async function scanArea() {
      const center = {
        lat: parseFloat(document.getElementById('centerLat').value),
        lng: parseFloat(document.getElementById('centerLng').value)
      };
      const outerRadius = parseInt(document.getElementById('outerRadius').value);
      const cellRadius = parseInt(document.getElementById('cellRadius').value);

      if (isNaN(center.lat) || isNaN(center.lng)) {
        updateStatus('Error: Invalid coordinates');
        return;
      }

      searchCancelled = false;
      const startBtn = document.getElementById('startSearch');
      const cancelBtn = document.getElementById('cancelSearch');
      
      startBtn.disabled = true;
      startBtn.classList.add('loading');
      cancelBtn.disabled = false;

      // Close mobile controls
      if (window.innerWidth < 768 && controlsExpanded) {
        toggleControls();
      }

      const cells = buildGridCenters(center, outerRadius, cellRadius);

      if (document.getElementById('showCells').checked) {
        for (const cell of cells) {
          const overlay = createCellOverlay(cell, cellRadius, false);
          cellOverlays.push(overlay);
        }
      }

      updateStatus(`🚀 Starting search: ${cells.length} cells to scan...`);
      updateProgress(0);
      document.getElementById('cellsScanned').textContent = `0/${cells.length}`;

      try {
        for (let i = 0; i < cells.length && !searchCancelled; i++) {
          currentCellIndex = i;

          updateCurrentCell(cells[i], cellRadius);

          updateStatus(`🔍 Scanning cell ${i + 1}/${cells.length}... (${searchResults.size} places found)`);
          updateProgress((i / cells.length) * 100);
          document.getElementById('cellsScanned').textContent = `${i + 1}/${cells.length}`;

          try {
            const [A, B] = await Promise.allSettled([
              nearbyAll(cells[i], cellRadius, i),
              textAll(cells[i], cellRadius, i)
            ]);

            if (!document.getElementById('showProgress').checked) {
              const batch = [
                ...(A.status === "fulfilled" ? A.value : []),
                ...(B.status === "fulfilled" ? B.value : [])
              ];
              for (const p of batch) {
                if (!searchResults.has(p.place_id)) {
                  searchResults.set(p.place_id, p);
                }
              }
            }

          } catch (e) {
            console.warn('Cell search error:', e);
          }

          await sleep(200);
        }

        currentCellIndex = -1;

        if (searchCancelled) {
          updateStatus('🛑 Search cancelled by user');
          return;
        }

        if (!document.getElementById('showProgress').checked) {
          updateStatus('🔄 Processing all results...');

          const minRating = parseFloat(document.getElementById('minRating').value);
          const minReviews = parseInt(document.getElementById('minReviews').value);

          const filteredPlaces = [...searchResults.values()]
            .filter(p => (p.types || []).includes("restaurant"))
            .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews);

          addResultsToMap(filteredPlaces, false);
          updateResultsList();
          updateStats();
        }

        updateProgress(100);
        updateStatus(`✅ Search complete! Found ${document.getElementById('filteredCount').textContent} restaurants matching your criteria`);

        if (currentCellOverlay) {
          currentCellOverlay.setMap(null);
          currentCellOverlay = null;
        }

      } catch (error) {
        updateStatus(`❌ Search failed: ${error}`);
      } finally {
        startBtn.disabled = false;
        startBtn.classList.remove('loading');
        cancelBtn.disabled = true;
      }
    }

    function updateStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function updateProgress(percent) {
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function getCurrentLocation() {
      const btn = document.getElementById('getCurrentLocation');
      const originalText = btn.textContent;
      
      btn.disabled = true;
      btn.textContent = 'Getting location...';

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            document.getElementById('centerLat').value = position.coords.latitude.toFixed(6);
            document.getElementById('centerLng').value = position.coords.longitude.toFixed(6);
            
            map.setCenter({
              lat: position.coords.latitude,
              lng: position.coords.longitude
            });
            map.setZoom(13);
            
            btn.disabled = false;
            btn.textContent = originalText;
            updateStatus('📍 Location updated');
          },
          (error) => {
            updateStatus(`Location error: ${error.message}`);
            btn.disabled = false;
            btn.textContent = originalText;
          }
        );
      } else {
        updateStatus('Geolocation not supported');
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    function toggleCellVisibility() {
      const showCells = document.getElementById('showCells').checked;
      for (const overlay of cellOverlays) {
        overlay.setMap(showCells ? map : null);
      }
      if (currentCellOverlay) {
        currentCellOverlay.setMap(showCells ? map : null);
      }
    }

    function initMap() {
      const center = { lat: 44.437, lng: 26.097 };

      map = new google.maps.Map(document.getElementById("map"), {
        center: center,
        zoom: 12,
        gestureHandling: 'greedy'
      });

      info = new google.maps.InfoWindow();
      svc = new google.maps.places.PlacesService(map);

      // Setup responsive behavior
      function handleResize() {
        const isMobile = window.innerWidth < 768;
        const desktopTitle = document.querySelector('h3[style*="display: none"]');
        const mobileHeader = document.querySelector('.mobile-header');
        
        if (isMobile) {
          desktopTitle.style.display = 'none';
          mobileHeader.style.display = 'flex';
          if (!controlsExpanded) {
            document.getElementById('controlsContent').classList.remove('expanded');
          }
        } else {
          desktopTitle.style.display = 'block';
          mobileHeader.style.display = 'none';
          document.getElementById('controlsContent').classList.remove('expanded');
          document.getElementById('controlsToggle').textContent = 'Settings';
          controlsExpanded = false;
        }
        
        google.maps.event.trigger(map, 'resize');
      }

      window.addEventListener('resize', handleResize);
      handleResize(); // Initial setup

      // Event listeners
      document.getElementById('controlsToggle').addEventListener('click', toggleControls);
      document.getElementById('startSearch').addEventListener('click', scanArea);
      document.getElementById('cancelSearch').addEventListener('click', () => {
        searchCancelled = true;
        updateStatus('Cancelling search...');
      });
      document.getElementById('clearResults').addEventListener('click', clearVisualElements);
      document.getElementById('getCurrentLocation').addEventListener('click', getCurrentLocation);
      document.getElementById('showCells').addEventListener('change', toggleCellVisibility);

      updateStatus('Ready to search. Configure parameters and click Start Search.');
      updateStats();
    }

    window.initMap = initMap;
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD0yHf3IW0QT2Rsu69esI_PzP0KXZLhksg&libraries=places&callback=initMap"></script>
</body>
</html>
