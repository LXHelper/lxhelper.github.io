<html>
<head>
  <meta charset="utf-8" />
  <title>Enhanced Restaurant Finder - Live Scanning</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 0; }
    .container { display: flex; height: 100vh; }
    #map { flex: 1; min-height: 500px; }

    #controls-panel {
      width: 320px;
      padding: 16px;
      background: #f8f9fa;
      overflow-y: auto;
      border-right: 1px solid #ddd;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
      box-sizing: border-box;
    }

    button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin: 4px 4px 4px 0;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    button:hover {
      opacity: 0.9;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    .toggle-row label {
      margin: 0;
      font-size: 12px;
    }

    input[type="checkbox"] {
      width: auto;
    }

    #results {
      max-height: 320px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    #results li {
      margin: 0;
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      font-size: 12px;
      line-height: 1.3;
    }

    #results li:hover {
      background: #f0f0f0;
    }

    #results li.selected {
      background: #e8f5e8;
      border-left: 4px solid #28a745;
    }

    #results li:last-child {
      border-bottom: none;
    }

    .new-result {
      background: #e8f5e8 !important;
      animation: highlight 2s ease-out;
    }

    @keyframes highlight {
      0% { background: #90ee90 !important; }
      100% { background: #e8f5e8 !important; }
    }

    #status {
      padding: 8px;
      margin-top: 8px;
      background: #e9ecef;
      border-radius: 4px;
      font-size: 12px;
      min-height: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      margin: 8px 0;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #007bff;
      transition: width 0.3s ease;
      width: 0%;
    }

    .coords-row {
      display: flex;
      gap: 8px;
    }

    .coords-row .form-group {
      flex: 1;
    }

    .stats {
      background: white;
      padding: 8px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 12px;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="controls-panel">
      <h3 style="margin-top: 0;">üçΩÔ∏è Restaurant Finder</h3>

      <div class="form-group">
        <label>Search Center</label>
        <div class="coords-row">
          <div class="form-group">
            <input type="number" id="centerLat" step="0.001" placeholder="Latitude" value="44.437">
          </div>
          <div class="form-group">
            <input type="number" id="centerLng" step="0.001" placeholder="Longitude" value="26.097">
          </div>
        </div>
        <button type="button" class="btn-secondary" id="getCurrentLocation">üìç Use My Location</button>
      </div>

      <div class="form-group">
        <label>Search Radius (km)</label>
        <input type="number" id="outerRadius" min="1" max="50" step="1" value="5">
      </div>

      <div class="form-group">
        <label>Cell Size (meters)</label>
        <input type="number" id="cellRadius" min="500" max="5000" step="100" value="1000">
      </div>

      <div class="form-group">
        <label>Minimum Rating</label>
        <select id="minRating">
          <option value="4.0">4.0+</option>
          <option value="4.2">4.2+</option>
          <option value="4.5">4.5+</option>
          <option value="4.7">4.7+</option>
          <option value="4.8" selected>4.8+</option>
          <option value="4.9">4.9+</option>
        </select>
      </div>

      <div class="form-group">
        <label>Minimum Reviews</label>
        <select id="minReviews">
          <option value="100">100+</option>
          <option value="500">500+</option>
          <option value="1000" selected>1000+</option>
          <option value="2000">2000+</option>
          <option value="5000">5000+</option>
        </select>
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="showCells" checked>
        <label for="showCells">Show scan cells</label>
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="showProgress" checked>
        <label for="showProgress">Live results</label>
      </div>

      <div style="margin: 16px 0;">
        <button type="button" class="btn-primary" id="startSearch">üîç Start Search</button>
        <button type="button" class="btn-danger" id="cancelSearch" disabled>‚èπÔ∏è Cancel</button>
        <button type="button" class="btn-secondary" id="clearResults">üóëÔ∏è Clear</button>
      </div>

      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <div id="status">Ready to search...</div>

      <div class="stats" id="statsPanel">
        <div class="stat-item">
          <span>Total Found:</span>
          <span id="totalCount">0</span>
        </div>
        <div class="stat-item">
          <span>Filtered:</span>
          <span id="filteredCount">0</span>
        </div>
        <div class="stat-item">
          <span>Cells Scanned:</span>
          <span id="cellsScanned">0/0</span>
        </div>
      </div>

      <div style="margin-top: 16px;">
        <strong>Results:</strong>
        <ul id="results"></ul>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // Configuration
    const CONFIG = {
      API_KEY: 'AIzaSyD0yHf3IW0QT2Rsu69esI_PzP0KXZLhksg'
    };

    let map, info, svc;
    let searchCancelled = false;
    let currentMarkers = [];
    let cellOverlays = [];
    let currentCellOverlay = null;
    let searchResults = new Map();
    let currentCellIndex = -1;
    let selectedMarker = null;
    let lastClickedPlace = null;
    let lastClickTime = 0;

    // Utility functions
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const toRad = (x) => x * Math.PI / 180;

    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const s1 = toRad(a.lat);
      const s2 = toRad(b.lat);
      const A = Math.sin(dLat / 2) ** 2 + Math.cos(s1) * Math.cos(s2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(A));
    }

    // Marker and selection functions
    function createMarkerIcon(isSelected = false) {
      return {
        url: `https://maps.google.com/mapfiles/ms/icons/${isSelected ? 'green' : 'red'}-dot.png`,
        scaledSize: new google.maps.Size(32, 32),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(16, 32)
      };
    }

    function selectMarker(marker, place) {
      // Reset previous selection
      if (selectedMarker && selectedMarker !== marker) {
        selectedMarker.setIcon(createMarkerIcon(false));
      }

      // Set new selection
      selectedMarker = marker;
      marker.setIcon(createMarkerIcon(true));

      // Show info window
      info.setContent(`<b>${place.name}</b><br>‚≠ê ${place.rating} (${place.user_ratings_total} reviews)<br><small>Click again to open in Google Maps</small>`);
      info.open(map, marker);
    }

    function generateGoogleMapsUrl(place) {
      // Use place_id if available (most accurate)
      if (place.place_id) {
        return `https://www.google.com/maps/place/?q=place_id:${place.place_id}`;
      }

      // Fallback to coordinates and name
      const lat = place.geometry.location.lat();
      const lng = place.geometry.location.lng();
      const name = encodeURIComponent(place.name);
      return `https://www.google.com/maps/search/${name}/@${lat},${lng},17z`;
    }

    function handlePlaceClick(place) {
      const currentTime = Date.now();
      const isDoubleClick = (lastClickedPlace === place.place_id && currentTime - lastClickTime < 500);

      if (isDoubleClick) {
        // Double click - open Google Maps
        const url = generateGoogleMapsUrl(place);
        window.open(url, '_blank');
        lastClickedPlace = null; // Reset to prevent triple-click issues
      } else {
        // Single click - select marker and highlight list item
        const marker = currentMarkers.find(m => m.getTitle() === place.name);
        if (marker) {
          selectMarker(marker, place);
        }

        // Highlight corresponding list item
        const listItems = document.querySelectorAll('#results li');
        listItems.forEach(li => li.classList.remove('selected'));

        const targetItem = [...listItems].find(li =>
          li.innerHTML.includes(`<strong>${place.name}</strong>`)
        );
        if (targetItem) {
          targetItem.classList.add('selected');
          targetItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        lastClickedPlace = place.place_id;
      }

      lastClickTime = currentTime;
    }

    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const s1 = toRad(a.lat);
      const s2 = toRad(b.lat);
      const A = Math.sin(dLat / 2) ** 2 + Math.cos(s1) * Math.cos(s2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(A));
    }

    // Visual cell functions
    function createCellOverlay(center, radius, isActive = false) {
      const circle = new google.maps.Circle({
        center: center,
        radius: radius,
        strokeColor: isActive ? '#ff4444' : '#4444ff',
        strokeOpacity: isActive ? 0.8 : 0.4,
        strokeWeight: isActive ? 3 : 1,
        fillColor: isActive ? '#ff4444' : '#4444ff',
        fillOpacity: isActive ? 0.15 : 0.05,
        map: document.getElementById('showCells').checked ? map : null
      });
      return circle;
    }

    function updateCurrentCell(center, radius) {
      if (currentCellOverlay) {
        currentCellOverlay.setMap(null);
      }
      if (document.getElementById('showCells').checked) {
        currentCellOverlay = createCellOverlay(center, radius, true);
      }
    }

    function clearVisualElements() {
      // Clear cell overlays
      for (const overlay of cellOverlays) {
        overlay.setMap(null);
      }
      cellOverlays = [];

      if (currentCellOverlay) {
        currentCellOverlay.setMap(null);
        currentCellOverlay = null;
      }

      // Clear markers
      for (const marker of currentMarkers) {
        marker.setMap(null);
      }
      currentMarkers = [];

      // Reset selection state
      selectedMarker = null;
      lastClickedPlace = null;
      lastClickTime = 0;

      // Clear results
      searchResults.clear();
      currentCellIndex = -1;
      updateResultsList();
      updateStats();
    }

    // Search functions with proper cell tracking
    function nearbyAll(center, radius, cellIndex) {
      return new Promise((resolve, reject) => {
        if (searchCancelled) return resolve([]);

        let acc = [];
        const req = {
          location: center,
          radius,
          keyword: "restaurant"
        };

        const cb = (res, status, pag) => {
          if (searchCancelled) return resolve(acc);

          if (status === google.maps.places.PlacesServiceStatus.OK) {
            acc = acc.concat(res || []);

            // Only process results immediately if live results are enabled
            // AND this is the current cell being scanned
            if (document.getElementById('showProgress').checked && cellIndex === currentCellIndex) {
              processPartialResults(res || [], center, radius);
            }

            if (pag && pag.hasNextPage && !searchCancelled) {
              return setTimeout(() => pag.nextPage(), 2000);
            }
            resolve(acc);
          } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
            resolve(acc);
          } else {
            reject(status);
          }
        };

        svc.nearbySearch(req, cb);
      });
    }

    function textAll(center, radius, cellIndex) {
      return new Promise((resolve, reject) => {
        if (searchCancelled) return resolve([]);

        let acc = [];
        const req = {
          query: "restaurant",
          location: center,
          radius
        };

        const cb = (res, status, pag) => {
          if (searchCancelled) return resolve(acc);

          if (status === google.maps.places.PlacesServiceStatus.OK) {
            acc = acc.concat(res || []);

            // Only process results immediately if live results are enabled
            // AND this is the current cell being scanned
            if (document.getElementById('showProgress').checked && cellIndex === currentCellIndex) {
              processPartialResults(res || [], center, radius);
            }

            if (pag && pag.hasNextPage && !searchCancelled) {
              return setTimeout(() => pag.nextPage(), 2000);
            }
            resolve(acc);
          } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
            resolve(acc);
          } else {
            reject(status);
          }
        };

        svc.textSearch(req, cb);
      });
    }

    // Process results in real-time - only for current cell
    function processPartialResults(newPlaces, cellCenter, cellRadius) {
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      let newValidResults = [];

      for (const place of newPlaces) {
        if (!searchResults.has(place.place_id)) {
          // Check if place is actually within the current cell being scanned
          const placeLocation = {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng()
          };

          const distanceToCell = haversine(cellCenter, placeLocation);

          // Only process if the place is reasonably close to the cell center
          if (distanceToCell <= cellRadius * 1.5) { // Allow some tolerance
            searchResults.set(place.place_id, place);

            // Check if it meets our criteria
            if ((place.types || []).includes("restaurant") &&
                (place.rating || 0) >= minRating &&
                (place.user_ratings_total || 0) >= minReviews) {
              newValidResults.push(place);
            }
          }
        }
      }

      // Add new valid results to map and list
      if (newValidResults.length > 0) {
        addResultsToMap(newValidResults, true);
        updateResultsList();
        updateStats();
      }
    }

    // Add results to map with selection functionality
    function addResultsToMap(places, isNew = false) {
      for (const place of places) {
        const marker = new google.maps.Marker({
          position: place.geometry.location,
          map,
          title: place.name,
          icon: createMarkerIcon(false),
          animation: isNew ? google.maps.Animation.DROP : null
        });

        // Store place data in marker for easy access
        marker.placeData = place;

        marker.addListener("click", () => {
          handlePlaceClick(place);
        });

        currentMarkers.push(marker);
      }
    }

    // Update results list
    function updateResultsList() {
      const ul = document.getElementById("results");
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      const filteredPlaces = [...searchResults.values()]
        .filter(p => (p.types || []).includes("restaurant"))
        .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews)
        .sort((a, b) => (b.rating - a.rating) || (b.user_ratings_total - a.user_ratings_total));

      ul.innerHTML = "";

      if (filteredPlaces.length === 0) {
        const li = document.createElement("li");
        li.textContent = searchResults.size > 0 ? "No restaurants match your criteria yet..." : "No results yet...";
        li.style.fontStyle = "italic";
        li.style.cursor = "default";
        ul.appendChild(li);
        return;
      }

      for (const place of filteredPlaces) {
        const li = document.createElement("li");
        li.innerHTML = `<strong>${place.name}</strong><br>‚≠ê ${place.rating} (${place.user_ratings_total} reviews)<br><small>Click again to open in Google Maps</small>`;

        // Use the same click handler as markers
        li.onclick = () => handlePlaceClick(place);

        ul.appendChild(li);
      }

      // Auto-scroll to show new results
      ul.scrollTop = ul.scrollHeight;
    }

    // Update statistics
    function updateStats() {
      const minRating = parseFloat(document.getElementById('minRating').value);
      const minReviews = parseInt(document.getElementById('minReviews').value);

      const filteredCount = [...searchResults.values()]
        .filter(p => (p.types || []).includes("restaurant"))
        .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews)
        .length;

      document.getElementById('totalCount').textContent = searchResults.size;
      document.getElementById('filteredCount').textContent = filteredCount;
    }

    // Grid generation
    function buildGridCenters(center, outerKm, cellM) {
      const kmPerDegLat = 111.32;
      const stepKm = (cellM * 1.2) / 1000; // 20% overlap
      const latStep = stepKm / kmPerDegLat;
      const lngStep = latStep / Math.cos(center.lat * Math.PI / 180);
      const steps = Math.ceil(outerKm / stepKm);
      const pts = [];

      for (let iy = -steps; iy <= steps; iy++) {
        for (let ix = -steps; ix <= steps; ix++) {
          const c = {
            lat: center.lat + iy * latStep,
            lng: center.lng + ix * lngStep
          };
          if (haversine(center, c) <= outerKm * 1000) {
            pts.push(c);
          }
        }
      }
      return pts;
    }

    // Main search function with visualization
    async function scanArea() {
      const center = {
        lat: parseFloat(document.getElementById('centerLat').value),
        lng: parseFloat(document.getElementById('centerLng').value)
      };
      const outerRadius = parseInt(document.getElementById('outerRadius').value);
      const cellRadius = parseInt(document.getElementById('cellRadius').value);

      // Validation
      if (isNaN(center.lat) || isNaN(center.lng)) {
        updateStatus('Error: Invalid coordinates');
        return;
      }

      searchCancelled = false;
      document.getElementById('startSearch').disabled = true;
      document.getElementById('cancelSearch').disabled = false;

      const cells = buildGridCenters(center, outerRadius, cellRadius);

      // Pre-draw all cell boundaries
      if (document.getElementById('showCells').checked) {
        for (const cell of cells) {
          const overlay = createCellOverlay(cell, cellRadius, false);
          cellOverlays.push(overlay);
        }
      }

      updateStatus(`üöÄ Starting search: ${cells.length} cells to scan...`);
      updateProgress(0);
      document.getElementById('cellsScanned').textContent = `0/${cells.length}`;

      try {
        for (let i = 0; i < cells.length && !searchCancelled; i++) {
          currentCellIndex = i; // Track current cell for filtering results

          // Highlight current cell
          updateCurrentCell(cells[i], cellRadius);

          updateStatus(`üîç Scanning cell ${i + 1}/${cells.length}... (${searchResults.size} places found)`);
          updateProgress((i / cells.length) * 100);
          document.getElementById('cellsScanned').textContent = `${i + 1}/${cells.length}`;

          try {
            const [A, B] = await Promise.allSettled([
              nearbyAll(cells[i], cellRadius, i),
              textAll(cells[i], cellRadius, i)
            ]);

            // If live results is disabled, process all results at the end
            if (!document.getElementById('showProgress').checked) {
              const batch = [
                ...(A.status === "fulfilled" ? A.value : []),
                ...(B.status === "fulfilled" ? B.value : [])
              ];
              for (const p of batch) {
                if (!searchResults.has(p.place_id)) {
                  searchResults.set(p.place_id, p);
                }
              }
            }

          } catch (e) {
            console.warn('Cell search error:', e);
          }

          await sleep(200); // Slightly longer delay for better visualization
        }

        currentCellIndex = -1; // Reset after scanning

        if (searchCancelled) {
          updateStatus('üõë Search cancelled by user');
          return;
        }

        // Final processing if live results was disabled
        if (!document.getElementById('showProgress').checked) {
          updateStatus('üîÑ Processing all results...');

          const minRating = parseFloat(document.getElementById('minRating').value);
          const minReviews = parseInt(document.getElementById('minReviews').value);

          const filteredPlaces = [...searchResults.values()]
            .filter(p => (p.types || []).includes("restaurant"))
            .filter(p => (p.rating || 0) >= minRating && (p.user_ratings_total || 0) >= minReviews);

          addResultsToMap(filteredPlaces, false);
          updateResultsList();
          updateStats();
        }

        updateProgress(100);
        updateStatus(`‚úÖ Search complete! Found ${document.getElementById('filteredCount').textContent} restaurants matching your criteria`);

        // Remove current cell highlight
        if (currentCellOverlay) {
          currentCellOverlay.setMap(null);
          currentCellOverlay = null;
        }

      } catch (error) {
        updateStatus(`‚ùå Search failed: ${error}`);
      } finally {
        document.getElementById('startSearch').disabled = false;
        document.getElementById('cancelSearch').disabled = true;
      }
    }

    // UI helper functions
    function updateStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function updateProgress(percent) {
      document.getElementById('progressFill').style.width = percent + '%';
    }

    // Geolocation
    function getCurrentLocation() {
      const btn = document.getElementById('getCurrentLocation');
      btn.disabled = true;
      btn.textContent = 'üîÑ Getting location...';

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            document.getElementById('centerLat').value = position.coords.latitude.toFixed(6);
            document.getElementById('centerLng').value = position.coords.longitude.toFixed(6);
            btn.disabled = false;
            btn.textContent = 'üìç Use My Location';
          },
          (error) => {
            updateStatus(`Location error: ${error.message}`);
            btn.disabled = false;
            btn.textContent = 'üìç Use My Location';
          }
        );
      } else {
        updateStatus('Geolocation not supported');
        btn.disabled = false;
        btn.textContent = 'üìç Use My Location';
      }
    }

    // Toggle cell visibility
    function toggleCellVisibility() {
      const showCells = document.getElementById('showCells').checked;
      for (const overlay of cellOverlays) {
        overlay.setMap(showCells ? map : null);
      }
      if (currentCellOverlay) {
        currentCellOverlay.setMap(showCells ? map : null);
      }
    }

    // Initialize map
    function initMap() {
      const center = { lat: 44.437, lng: 26.097 };

      map = new google.maps.Map(document.getElementById("map"), {
        center: center,
        zoom: 12
      });

      info = new google.maps.InfoWindow();
      svc = new google.maps.places.PlacesService(map);

      // Event listeners
      document.getElementById('startSearch').addEventListener('click', scanArea);
      document.getElementById('cancelSearch').addEventListener('click', () => {
        searchCancelled = true;
        updateStatus('üõë Cancelling search...');
      });
      document.getElementById('clearResults').addEventListener('click', clearVisualElements);
      document.getElementById('getCurrentLocation').addEventListener('click', getCurrentLocation);
      document.getElementById('showCells').addEventListener('change', toggleCellVisibility);

      updateStatus('üéØ Ready to search. Configure parameters and click Start Search.');
      updateStats();
    }

    window.initMap = initMap;
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD0yHf3IW0QT2Rsu69esI_PzP0KXZLhksg&libraries=places&callback=initMap"></script>
</body>
</html>
